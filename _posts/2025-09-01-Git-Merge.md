---
title : Git_Merge의 종류
date : 2025-09-01 00:40:00 +9:00
categories : [Git]
tags : [Javascript, Git]
---
## 1. Merge Commit(3-way merge)
두 브랜치의 변경 사항을 모두 유지하며 메인 브랜치에 다른 브랜치를 merge하는 방식
이 경우 각 브랜치의 변경 사항들이 과거의 커밋으로 보존되며, 병합 시 메인 브랜치에 새로운 'merge commit'이 추가되며 병합이 완료된다. feature 브랜치의 가장 최근 커밋이 메인 브랜치로 병합되는 것을 볼 수 있다. 

### 특징
- 프로젝트의 진행 상황을 명확히 추적할 수 있음
- 브랜치 별 변경 사항이 유지되므로 커밋들의 아이디가 바뀌지 않음
- 병합이 될 때마다 커밋이 생기므로 다양한 브랜치를 병합하면 커밋 로그가 매우 복잡해 질 수 있음
- 대규모 인원이 참여하는 프로젝트에서는 복잡도가 빠르게 증가

##  2. Squash Merge
병합할 브랜치의 모든 변경 사항을 하나의 커밋으로 합쳐 메인 브랜치에 병합
이 경우 병합되는 브랜치의 변경 사항들은 사라지며, 모든 변경 사항이 합쳐진 한 개의 커밋이 새로운 아이디를 가지고 메인 브랜치에 추가되며 병합이 완료

### 특징
- 커밋 히스토리를 간단하게 유지할 수 있음
- 각 커밋들이 합쳐지며 가장 중요한 내용이 담긴 하나의 커밋으로 압축됨
- 각 커밋에 담겨 있던 세부적인 작업 이력을 잃게 됨
- 개별적인 맥락을 알 수 없으므로 문제가 발생한 부분을 찾기 어려움
- 기존에 존재하던 커밋 아이디들이 하나의 새로운 아이디로 생성되므로 기존 브랜치를 기반으로 한 작업에 문제가 생길 수 있음
- squash 방식을 사용한다고 해서 기존의 커밋 내역이 완전히 삭제되는 것은 아님
- gitHub에는 기존의 커밋 내역들이 모두 남아있기 때문에 이전의 pull request를 찾아 해당 작업의 커밋 히스토리를 확인할 수 있다.

## 3. Rebase Merge
현재 위치한 브랜치를, 병합시킬 타겟 브랜치에 재위치(rebase)시킨 뒤 병합
기준이 되는 베이스 브랜치를 변경(re-base)한다고 생각하면 됨, 현재 위치한 브랜치의 모든 커밋을 타겟 브랜치로 옮기기 때문에 커밋 아이디가 변경, 브랜치가 분기되고 난 후에 발생한 커밋A, B가 각각 새로운 커밋으로 메인 브랜치에 병합

### 특징
- 커밋 히스토리가 선형적으로 깔끔하게 유지됨
- 깨끗한 히스토리 덕분에 변경 사항들을 쉽게 파악할 수 있음
- 기존에 존재하던 커밋 아이디들이 각각 새로운 아이디로 생성되므로 기존 브랜치를 기반으로 한 작업에 문제가 생길 수 있음
- 다양한 브랜치가 존재할 경우 병합이 어려움
- 선형적이라는 특징으로 인해 특정 기능이 어디부터 어디까지의 커밋으로 구현되었는지 알 수 없음

## 4. Fast-forward Merge

- 새로운 merge commit을 생성하지 않고, 현재 위치한 브랜치의 최신 커밋 = HEAD가 가리키고 있는 커밋이 병합할 브랜치의 최신 커밋으로 이동하며 병합
- 메인 브랜치에서 다른 브랜치가 분기되었지만, 다른 브랜치에서만 새로운 커밋이 생기고 메인 브랜치에서는 아무런 변화가 없는 경우 fast-forward merge가 발생, 분기된 후에 메인 브랜치에는 새로운 커밋이 생기지 않았으므로 메인 브랜치와 분기된 브랜치의 커밋 히스토리는 동일한 선 상에 위치하고 있다고 볼 수 있다.

### 특징
- squash  merge는 다른 브랜치의 커밋들을 합쳐서 하나의 커밋으로 만든 뒤 병합하지만, fast-forward merge는 기존의 커밋들이 유지
- rebash  merge는 메인 브랜치와 분기된 브랜치 둘 다에 새로운 커밋이 존재하는 상태에서 병합이 진행되지만, fast-forward merge는 메인 브랜치에는 변경 사항이 없는 상태에서 병합 됨.
